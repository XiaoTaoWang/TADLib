<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tadlib.hitad.chromLev &#8212; TADLib 0.3.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">TADLib</a></h1>



<p class="blurb">A Library to Explore Chromatin Interaction Patterns for Topologically Associating Domains</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=XiaoTaoWang&repo=TADLib&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install TADLib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../calfea.html">Aggregation Preference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hitad.html">Hierarchical TAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Release Notes</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tadlib.hitad.chromLev</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue May 31 15:47:34 2016</span>

<span class="sd">@author: wxt</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">aligner</span> <span class="k">import</span> <span class="n">BoundSet</span><span class="p">,</span> <span class="n">DomainSet</span><span class="p">,</span> <span class="n">DomainAligner</span><span class="p">,</span> <span class="n">hierFormat</span><span class="p">,</span> <span class="n">Container</span>
<span class="kn">from</span> <span class="nn">tadlib.calfea</span> <span class="k">import</span> <span class="n">analyze</span>

<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">Normalize</span>

<span class="k">class</span> <span class="nc">MidpointNormalize</span><span class="p">(</span><span class="n">Normalize</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">midpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">=</span> <span class="n">midpoint</span>
        <span class="n">Normalize</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">clip</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmin</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vmin</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmin</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span> <span class="o">=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Chrom"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom">[docs]</a><span class="k">class</span> <span class="nc">Chrom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *Chrom* is defined to:</span>
<span class="sd">    </span>
<span class="sd">    - Hold Hi-C data within a certain chromosome</span>
<span class="sd">    - Identify hierarchical domains in 4 steps: 1.Calculate adaptive DIs for</span>
<span class="sd">      all bins of the considered chromosome. 2.Identify original candidate</span>
<span class="sd">      bounds by 5-state Gaussian mixture Hidden Markov Model using adaptive</span>
<span class="sd">      DIs as input. 3.Select TAD bounds from candidate bounds. 4.Recursively</span>
<span class="sd">      identify inner domain structures of each TAD.</span>
<span class="sd">    - Visualize any region of the chromosome. Hierarchical domains will be</span>
<span class="sd">      plotted as boxes along with the diagonal of the heatmap, and adaptive</span>
<span class="sd">      DI track will be placed on top of the heatmap.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chrom : str</span>
<span class="sd">        Chromosome label.</span>
<span class="sd">    </span>
<span class="sd">    res : int</span>
<span class="sd">        Resolution of the Hi-C data in base-pair unit.</span>
<span class="sd">    </span>
<span class="sd">    hicdata : numpy.ndarray</span>
<span class="sd">        Hi-C data stored in our customized Numpy Structured Array. The</span>
<span class="sd">        structured array is defined in :py:class:`tadlib.hitad.genomeLev.Genome`,</span>
<span class="sd">        and it has 3 fields named &quot;bin1&quot;, &quot;bin2&quot; and &quot;IF&quot;, respectively.</span>
<span class="sd">    </span>
<span class="sd">    replabel : str</span>
<span class="sd">        Biological replicate label.</span>
<span class="sd">    </span>
<span class="sd">    maxapart : int</span>
<span class="sd">        Maximum allowable TAD size in base-pair unit. (Default: 4000000)</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    chrom : str</span>
<span class="sd">        Chromosome label.</span>
<span class="sd">    </span>
<span class="sd">    res : int</span>
<span class="sd">        Resolution in base-pair unit.</span>
<span class="sd">    </span>
<span class="sd">    maxapart : int</span>
<span class="sd">        Maximum allowable TAD size.</span>
<span class="sd">    </span>
<span class="sd">    replabel : str</span>
<span class="sd">        Biological replicate label.</span>
<span class="sd">    </span>
<span class="sd">    chromLen : int</span>
<span class="sd">        Total bin number of the chromosome. Obtained from Hi-C data.</span>
<span class="sd">    </span>
<span class="sd">    rawMatrix : sparse matrix in Compressed Sparse Row format</span>
<span class="sd">        CSR sparse matrix is used to extract Hi-C data by slicing conveniently</span>
<span class="sd">        while guarantee low memory overhead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">defaultwindow</span> <span class="o">=</span> <span class="mi">2000000</span>
    <span class="n">minsize</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">hicdata</span><span class="p">,</span> <span class="n">replabel</span><span class="p">,</span> <span class="n">maxapart</span><span class="o">=</span><span class="mi">4000000</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxapart</span> <span class="o">=</span> <span class="n">maxapart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replabel</span> <span class="o">=</span> <span class="n">replabel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rm</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultwindow</span> <span class="o">//</span> <span class="n">res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxapart</span> <span class="o">//</span> <span class="n">res</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">hicdata</span><span class="p">[</span><span class="s1">&#39;bin1&#39;</span><span class="p">];</span> <span class="n">y</span> <span class="o">=</span> <span class="n">hicdata</span><span class="p">[</span><span class="s1">&#39;bin2&#39;</span><span class="p">];</span> <span class="n">IF</span> <span class="o">=</span> <span class="n">hicdata</span><span class="p">[</span><span class="s1">&#39;IF&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genSparseMatrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">IF</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">IF</span><span class="p">,</span> <span class="n">hicdata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="s1">&#39;Submitted&#39;</span>

    <span class="k">def</span> <span class="nf">_genSparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">IF</span><span class="p">):</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;0,2,1&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">chromLen</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">extendLen</span> <span class="o">=</span> <span class="n">chromLen</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">chromLen</span>
        <span class="n">rawMatrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">IF</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">chromLen</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">chromLen</span><span class="p">)),</span>
                                      <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">extendLen</span><span class="p">,</span> <span class="n">extendLen</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">chromLen</span><span class="p">,</span> <span class="n">rawMatrix</span>

<div class="viewcode-block" id="Chrom.detectPeaks"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.detectPeaks">[docs]</a>    <span class="k">def</span> <span class="nf">detectPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trends</span><span class="p">,</span> <span class="n">mph</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mpd</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect peaks (local maxima) in a 1-D array intuitively (a peak must</span>
<span class="sd">        be greater than its immediate neighbors).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trends : 1-D numpy ndarray</span>
<span class="sd">            Data.</span>
<span class="sd">        </span>
<span class="sd">        mph : float</span>
<span class="sd">            Only peaks that are greater than this value will be detected.</span>
<span class="sd">            (Default: 0)</span>
<span class="sd">        </span>
<span class="sd">        mpd : positive integer</span>
<span class="sd">            Only peaks whose indices are at least separated by this value will</span>
<span class="sd">            be reported. (Default: 5)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ind : 1-D numpy ndarray</span>
<span class="sd">            Indices of peaks detected in *trends*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">trends</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">trends</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">trends</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">trends</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Filter peaks by mph</span>
        <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">trends</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mph</span><span class="p">]</span>

        <span class="c1"># Remove small peaks closer than mpd</span>
        <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">mpd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">trends</span><span class="p">[</span><span class="n">ind</span><span class="p">])][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">idel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idel</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">idel</span> <span class="o">=</span> <span class="n">idel</span> <span class="o">|</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mpd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">mpd</span><span class="p">)</span> \
                           <span class="o">&amp;</span> <span class="p">(</span><span class="n">trends</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">trends</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                    <span class="n">idel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="o">~</span><span class="n">idel</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="Chrom.randomCheck"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.randomCheck">[docs]</a>    <span class="k">def</span> <span class="nf">randomCheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">pthre</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We use chi square test to test the randomness of a sequence by</span>
<span class="sd">        looking at the conversion frequency between neighbors in the sequence.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq : str</span>
<span class="sd">            A string containing only &#39;1&#39; or &#39;0&#39;. (e.g. &#39;101000101&#39;)</span>
<span class="sd">        </span>
<span class="sd">        pthre : float, 0-1</span>
<span class="sd">            Significance level of the hypothesis tests.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reject : bool</span>
<span class="sd">            True if we should reject the null hypothesis (the sequence is</span>
<span class="sd">            generated randomly) under the selected significance level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">izip</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">chisquare</span>

        <span class="n">pairwise</span> <span class="o">=</span> <span class="n">izip</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span> <span class="o">*</span> <span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">pval</span> <span class="o">=</span>  <span class="n">chisquare</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
        <span class="n">reject</span> <span class="o">=</span> <span class="n">pval</span><span class="o">&lt;=</span><span class="n">pthre</span>

        <span class="k">return</span> <span class="n">reject</span></div>

<div class="viewcode-block" id="Chrom.oriWindow"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.oriWindow">[docs]</a>    <span class="k">def</span> <span class="nf">oriWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the most appropriate window size for current bin to best</span>
<span class="sd">        capture the local interaction bias direction.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P : 1-D numpy.ndarray</span>
<span class="sd">            Calculated by the formula P\ :sub:`i`\ (k) = M\ :sub:`i-k,k` -</span>
<span class="sd">            M\ :sub:`i,i+k`, where *M* represents the contact matrix, *i*</span>
<span class="sd">            represents current bin index, and *k* indicates bin-level genomic</span>
<span class="sd">            distances. This is an intuitive definition of interaction bias</span>
<span class="sd">            for each genomic distance: if the sign of an entry is positive,</span>
<span class="sd">            then bin *i* is more likely to contact with the upstream bin</span>
<span class="sd">            *i-k*; otherwise it&#39;s more inclined to contact with the downstream</span>
<span class="sd">            bin *i+k*.</span>
<span class="sd">        </span>
<span class="sd">        Design</span>
<span class="sd">        ------</span>
<span class="sd">        Because of the presence of local domains, we can see runs of values</span>
<span class="sd">        in *P* with consistent signs. The object of this method is to determine</span>
<span class="sd">        the cut of the first run. For the beginning of a domain, the values</span>
<span class="sd">        in the first run tend to be negative, and for the end of a domain,</span>
<span class="sd">        they are almost positive.</span>
<span class="sd">        </span>
<span class="sd">        The cut sites of the runs can be approximated by detecting peaks on</span>
<span class="sd">        the trend of positive/negative value ratio under increasing *k*. And</span>
<span class="sd">        the existence of runs under certain *k* can be determined by checking</span>
<span class="sd">        the randomness of the sequence.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.detectPeaks : detect peaks given a 1-D array</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.randomCheck : randomness test for a two-valued</span>
<span class="sd">                                                  (0-1) sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">noise</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">noiselevel</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">check</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">noiselevel</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># Downstream bias</span>
             <span class="n">P</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># Upstream bias</span>

        <span class="n">trends_1</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">trends_2</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">detectPeaks</span><span class="p">(</span><span class="n">trends_1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detectPeaks</span><span class="p">(</span><span class="n">trends_2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">pool</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="n">pool</span><span class="p">[</span><span class="n">p</span><span class="p">]][:(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)]])</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minsize</span><span class="p">:</span> <span class="c1"># hasn&#39;t been systematically tested</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomCheck</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">tmp</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dw</span></div>

<div class="viewcode-block" id="Chrom.minWindows"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.minWindows">[docs]</a>    <span class="k">def</span> <span class="nf">minWindows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">maxw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate best window size for every bin of a given range.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int</span>
<span class="sd">            Specify range of the bin indices.</span>
<span class="sd">        </span>
<span class="sd">        maxw : int</span>
<span class="sd">            Maximum allowable window size.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        windows : 1-D numpy.ndarray, int32</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.oriWindow : Window size estimation for</span>
<span class="sd">                                                a single bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span><span class="p">;</span> <span class="n">end</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="n">maxw</span><span class="p">)]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="n">maxw</span><span class="o">+</span><span class="mi">1</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">down</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">up</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">up</span> <span class="o">-</span> <span class="n">down</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriWindow</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">ws</span></div>

<div class="viewcode-block" id="Chrom.calDI"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.calDI">[docs]</a>    <span class="k">def</span> <span class="nf">calDI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Directionality Index (DI) for each bin with adaptive</span>
<span class="sd">        window size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        windows : 1-D numpy.ndarray, int32</span>
<span class="sd">            Returned by :py:meth:`tadlib.hitad.chromLev.Chrom.minWindows`.</span>
<span class="sd">        start : int</span>
<span class="sd">            Starting bin index, the window size of which is taken from the</span>
<span class="sd">            1st place of *windows*.</span>
<span class="sd">    </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        DIs : 1-D numpy ndarray, float</span>
<span class="sd">            Calculated adaptive DI array, which has the same size as the</span>
<span class="sd">            input *windows*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">DIs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="n">w</span><span class="p">)]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">down</span> <span class="o">=</span> <span class="n">down</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span><span class="p">:];</span> <span class="n">up</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binbias</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>

        <span class="c1"># trim outliers</span>
        <span class="n">lthre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">hthre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="o">&lt;</span><span class="n">lthre</span><span class="p">]</span> <span class="o">=</span> <span class="n">lthre</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="o">&gt;</span><span class="n">hthre</span><span class="p">]</span> <span class="o">=</span> <span class="n">hthre</span></div>

    <span class="k">def</span> <span class="nf">_binbias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">):</span>

        <span class="n">bias</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">zeromask</span> <span class="o">=</span> <span class="p">(</span><span class="n">up</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">down</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zeromask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">zeromask</span><span class="p">];</span> <span class="n">down</span> <span class="o">=</span> <span class="n">down</span><span class="p">[</span><span class="n">zeromask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">up</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bias</span>
        
        <span class="n">upmean</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">mean</span><span class="p">();</span> <span class="n">downmean</span> <span class="o">=</span> <span class="n">down</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">SD_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">up</span> <span class="o">-</span> <span class="n">upmean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">SD_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">down</span> <span class="o">-</span> <span class="n">downmean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">down</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="n">down</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">SD_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SD_1</span> <span class="o">+</span> <span class="n">SD_2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">SD_pool</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bias</span> <span class="o">=</span> <span class="p">(</span><span class="n">upmean</span> <span class="o">-</span> <span class="n">downmean</span><span class="p">)</span> <span class="o">/</span> <span class="n">SD_pool</span>

        <span class="k">return</span> <span class="n">bias</span>

<div class="viewcode-block" id="Chrom.oriHMMParams"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.oriHMMParams">[docs]</a>    <span class="k">def</span> <span class="nf">oriHMMParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initial parameters for the Hidden Markov Model (HMM).</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        HMMParams : dict</span>
<span class="sd">            Has 3 keys: &quot;A&quot;, state transition matrix, &quot;B&quot; (emission probabilities),</span>
<span class="sd">            specifying parameters (Means, Variances, Weights) of the mixture</span>
<span class="sd">            Gaussian distributions for each hidden state, and &quot;pi&quot;, indicating</span>
<span class="sd">            the hidden state weights. This dict will be updated after learning</span>
<span class="sd">            procedure.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.paramFromModel : Learn HMM parameters</span>
<span class="sd">                                                     from sequence data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;HMMParams&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="c1"># Five Hidden States:</span>
            <span class="c1"># 0--start, 1--downstream, 2--no bias, 3--upstream, 4--end</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                 <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                 <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                 <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                 <span class="p">[</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
            <span class="n">numdists</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Three-distribution Gaussian Mixtures</span>
            <span class="n">W</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">numdists</span>
            <span class="n">var</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">means</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdists</span><span class="p">):</span>
                <span class="n">means</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span> <span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span>
                <span class="n">means</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span> <span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">))</span>
                <span class="n">means</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">numdists</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">means</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">*</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span> <span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">))</span>
                <span class="n">means</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">*</span> <span class="mf">7.5</span> <span class="o">/</span> <span class="p">(</span> <span class="n">numdists</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span>

            <span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdists</span><span class="p">)],</span> <span class="p">[</span><span class="n">W</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdists</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">))]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">HMMParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="n">pi</span><span class="p">}</span></div>

<div class="viewcode-block" id="Chrom.splitChrom"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.splitChrom">[docs]</a>    <span class="k">def</span> <span class="nf">splitChrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DIs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split a chromosome into gap-free regions. HMM learning and domain</span>
<span class="sd">        identification procedure will be performed on these region separately.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        DIs : 1-D numpy ndarray, float</span>
<span class="sd">            Adaptive DI array of the whole chromosome. Generally, we detect</span>
<span class="sd">            runs of zeros in the array as gaps, which will be cut off the</span>
<span class="sd">            chromosome, making entire chromosome pieces of gap-free regions.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        chromRegions : dict, {(start,end):DIs[start:end]}</span>
<span class="sd">            The keys are gap-free regions, and the values are corresponding</span>
<span class="sd">            adaptive DI pieces.</span>
<span class="sd">        gapbins : set</span>
<span class="sd">            Set of bins (in base-pair unit) located in gap regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># minregion and maxgaplen are set intuitively</span>
        <span class="n">maxgaplen</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
        <span class="n">minregion</span> <span class="o">=</span> <span class="n">maxgaplen</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="n">valid_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">DIs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gapsizes</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">valid_pos</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">endsIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gapsizes</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">maxgaplen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">startsIdx</span> <span class="o">=</span> <span class="n">endsIdx</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">chromRegions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startsIdx</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="n">startsIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="n">endsIdx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">minregion</span><span class="p">:</span>
                <span class="n">chromRegions</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DIs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">startsIdx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="n">startsIdx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">minregion</span><span class="p">:</span>
                <span class="n">chromRegions</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DIs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="n">endsIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">minregion</span><span class="p">:</span>
                <span class="n">chromRegions</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DIs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">startsIdx</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">valid_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">minregion</span><span class="p">:</span>
                <span class="n">chromRegions</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DIs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">chromRegions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Empty DI sequences for HMM training&#39;</span><span class="p">)</span>

        <span class="n">gapmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">DIs</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">chromRegions</span><span class="p">:</span>
            <span class="n">gapmask</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">gapbins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gapmask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">regionDIs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gapbins</span> <span class="o">=</span> <span class="n">chromRegions</span><span class="p">,</span> <span class="n">gapbins</span></div>

<div class="viewcode-block" id="Chrom.paramFromModel"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.paramFromModel">[docs]</a>    <span class="k">def</span> <span class="nf">paramFromModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seqs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train HMM model on *seqs* using `GHMM &lt;http://ghmm.sourceforge.net/index.html&gt;`_.</span>
<span class="sd">        Update *HMMParams* attribute after training.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seqs : list of list</span>
<span class="sd">            Each element is the adaptive DI list of a gap-free region.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.oriHMMParams : Set initial parameters</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.splitChrom : Split chromosome into gap-free</span>
<span class="sd">                                                 regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">ghmm</span>

        <span class="n">HMMParams</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;HMMParams&#39;</span><span class="p">)</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">ghmm</span><span class="o">.</span><span class="n">Float</span><span class="p">()</span>
        <span class="n">trainset</span> <span class="o">=</span> <span class="n">ghmm</span><span class="o">.</span><span class="n">SequenceSet</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">seqs</span><span class="p">)</span>

        <span class="c1"># Training ...</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">ghmm</span><span class="o">.</span><span class="n">HMMFromMatrices</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">ghmm</span><span class="o">.</span><span class="n">GaussianMixtureDistribution</span><span class="p">(</span><span class="n">F</span><span class="p">),</span>
                                     <span class="o">**</span><span class="n">HMMParams</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">baumWelch</span><span class="p">(</span><span class="n">trainset</span><span class="p">)</span>

        <span class="n">state_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
        <span class="n">numdists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">state_num</span><span class="p">,</span> <span class="n">state_num</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">state_num</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">numdists</span><span class="p">))</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">state_num</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_num</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_num</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdists</span><span class="p">):</span> <span class="c1"># num of distributions</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getEmission</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="c1"># Mean, var, weight</span>
                    <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>
        <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;pi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span></div>

<div class="viewcode-block" id="Chrom.learning"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.learning">[docs]</a>    <span class="k">def</span> <span class="nf">learning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regionDIs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare training data and learn HMM model parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regionDIs : dict</span>
<span class="sd">            Gap-free regions and corresponding adaptive DI arrays. Returned</span>
<span class="sd">            by :py:meth:`tadlib.hitad.chromLev.Chrom.splitChrom`.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.paramFromModel : core part for HMM learning</span>
<span class="sd">                                                     and parameter updating.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">random</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">oriHMMParams</span><span class="p">()</span>

        <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regionDIs</span><span class="p">:</span>
            <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">regionDIs</span><span class="p">[</span><span class="n">region</span><span class="p">]))</span>

        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">paramFromModel</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Chrom.viterbi"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.viterbi">[docs]</a>    <span class="k">def</span> <span class="nf">viterbi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the most likely hidden state series given the observed *seq*</span>
<span class="sd">        using the viterbi algorithm.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq : 1-D numbpy ndarray, float</span>
<span class="sd">            Adaptive DI array for any region.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        path : list</span>
<span class="sd">            List of hidden state labels. Has the same length as the input</span>
<span class="sd">            *seq*.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.paramFromModel : parameter learning</span>
<span class="sd">                                                     using Baum-Welch algorithm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span>

        <span class="n">HMMParams</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;HMMParams&#39;</span><span class="p">)</span>

        <span class="n">num_states</span> <span class="o">=</span> <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;pi&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">numdists</span> <span class="o">=</span> <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_states</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">))</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_states</span><span class="p">,</span> <span class="n">seq_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">transition_costs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdists</span><span class="p">):</span>
                <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                       <span class="n">scale</span> <span class="o">=</span> <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> \
                                       <span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
        <span class="n">costs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">HMMParams</span><span class="p">[</span><span class="s1">&#39;pi&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_states</span><span class="p">):</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">transition_costs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">min_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_states</span><span class="p">):</span>
                    <span class="n">next_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">transition_costs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">next_cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                        <span class="n">min_cost</span> <span class="o">=</span> <span class="n">next_cost</span>
                        <span class="n">min_state</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min_cost</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_state</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_states</span><span class="p">):</span>
            <span class="n">min_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">transition_costs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">min_state</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_states</span><span class="p">):</span>
                <span class="n">next_cost</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">transition_costs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">next_cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                    <span class="n">min_cost</span> <span class="o">=</span> <span class="n">next_cost</span>
                    <span class="n">min_state</span> <span class="o">=</span> <span class="n">k</span>
        
        <span class="n">min_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_states</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">[</span><span class="n">min_state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">min_state</span> <span class="o">=</span> <span class="n">j</span>

        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_state</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">path</span>

        <span class="k">return</span> <span class="n">path</span></div>

    <span class="k">def</span> <span class="nf">_getBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">junctions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;20&#39;</span><span class="p">,</span><span class="s1">&#39;40&#39;</span><span class="p">,</span><span class="s1">&#39;42&#39;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call boundary sites from hidden state series. By default, these</span>
<span class="sd">        transition modes will be detected as boundaries: &quot;no bias(2) </span>
<span class="sd">        domain start(0)&quot;, &quot;domain end(4)  domain start(0)&quot;, and &quot;domain end(4)</span>
<span class="sd">         no bias(2)&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : list</span>
<span class="sd">            Hidden state series returned by :py:meth:`tadlib.hitad.chromLev.Chrom.viterbi`.</span>
<span class="sd">        junctions : list of strings</span>
<span class="sd">            Boundary definitions by using state transition modes.</span>
<span class="sd">            (Default: [&#39;20&#39;,&#39;40&#39;,&#39;42&#39;])</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds : 1-D numpy ndarray, int</span>
<span class="sd">            Detected boundary positions in ascending order. 0 and len(*path*)</span>
<span class="sd">            will always be included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pathseq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathseq</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">junc</span> <span class="ow">in</span> <span class="n">junctions</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">junc</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">gen</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">pieces</span> <span class="o">=</span> <span class="n">gen</span>
            
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">pieces</span><span class="p">)]]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">bounds</span>

<div class="viewcode-block" id="Chrom.pipe"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.pipe">[docs]</a>    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform an observed sequence into a list of domains.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq : 1-D numbpy ndarray, float</span>
<span class="sd">            Adaptive DI array for any region.</span>
<span class="sd">        start : int</span>
<span class="sd">            Chromosome bin index of the *seq* start.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        domains : list</span>
<span class="sd">            List of domains in the format ``[start bin, end bin, noise level,</span>
<span class="sd">            hierarchical level]``.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.refNoise : Calculate the noise level of</span>
<span class="sd">                                               a given domain</span>
<span class="sd">        tadlib.hitad.aligner.BoundSet : where the meanings of the hierarchical</span>
<span class="sd">                                        level labels are explained in detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bin-level domain (not base-pair-level domain!)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">viterbi</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="c1"># start, end, noise level, hierarchical level</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">start</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">domains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">domains</span></div>

<div class="viewcode-block" id="Chrom.minCore"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.minCore">[docs]</a>    <span class="k">def</span> <span class="nf">minCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regionDIs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learner and Caller. Take adaptive DI arrays of all gap-free regions,</span>
<span class="sd">        learn HMM parameters, retrieve hidden state series, and finally</span>
<span class="sd">        output identified domain list for each region.</span>
<span class="sd">        </span>
<span class="sd">        In our implementation, this method is mainly used as a core for</span>
<span class="sd">        :py:meth:`tadlib.hitad.chromLev.Chrom.oriIter`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regionDIs : dict</span>
<span class="sd">            Gap-free regions and corresponding adaptive DI arrays.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        minDomains : dict</span>
<span class="sd">            Gap-free regions and corresponding identified bottom domain list.</span>
<span class="sd">            Different from :py:meth:`tadlib.hitad.chromLev.Chrom.pipe`, the</span>
<span class="sd">            start and the end of a domain are in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.oriIter : iteratively approximate adaptive</span>
<span class="sd">                                              window sizes and return final</span>
<span class="sd">                                              bottom domain lists.</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.splitChrom : by which the input learning</span>
<span class="sd">                                                 data can be calculated</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.pipe : take an adaptive DI array and return</span>
<span class="sd">                                           a list of domains after learning</span>
<span class="sd">                                           procedure has been completed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning</span><span class="p">(</span><span class="n">regionDIs</span><span class="p">)</span>
        <span class="n">tmpDomains</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">regionDIs</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">regionDIs</span><span class="p">[</span><span class="n">region</span><span class="p">]</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">tmpDomains</span><span class="p">[</span><span class="n">cr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">:</span>
                <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                <span class="n">domain</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refNoise</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                <span class="n">tmpDomains</span><span class="p">[</span><span class="n">cr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        
        <span class="n">minDomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orifilter</span><span class="p">(</span><span class="n">tmpDomains</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">minDomains</span></div>

<div class="viewcode-block" id="Chrom.getDomainList"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.getDomainList">[docs]</a>    <span class="k">def</span> <span class="nf">getDomainList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byregion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine by-region domains into a single list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        byregion : dict</span>
<span class="sd">            The keys are tuples representing gap-free regions of the chromosome,</span>
<span class="sd">            and the values are corresponding identified domain lists.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DomainList : list</span>
<span class="sd">            A merged domain list of all regions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DomainList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">byregion</span><span class="p">):</span>
            <span class="n">DomainList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">byregion</span><span class="p">[</span><span class="n">region</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">DomainList</span></div>

    <span class="k">def</span> <span class="nf">_orifilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oriDomains</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform size filtering on the input domain lists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oriDomains : dict</span>
<span class="sd">            The keys are tuples representing gap-free regions of the chromosome,</span>
<span class="sd">            and the values are corresponding identified domain lists. Start</span>
<span class="sd">            and end of the domain should be in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered : dict</span>
<span class="sd">            Pairs of gap-free regions and corresponding filtered domain lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">oriDomains</span><span class="p">:</span>
            <span class="n">tmplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">oriDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minsize</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">):</span>
                    <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmplist</span><span class="p">):</span>
                <span class="n">filtered</span><span class="p">[</span><span class="n">region</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmplist</span>
        <span class="k">return</span> <span class="n">filtered</span>

<div class="viewcode-block" id="Chrom.iterCore"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.iterCore">[docs]</a>    <span class="k">def</span> <span class="nf">iterCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minDomains</span><span class="p">,</span> <span class="n">tmpDomains</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the mismatch ratio for the input two domain lists. Return</span>
<span class="sd">        1 if *minDomains* is empty.</span>
<span class="sd">        </span>
<span class="sd">        :py:meth:`tadlib.hitad.chromLev.Chrom.oriIter` uses this method to</span>
<span class="sd">        determine whether to break the iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minDomains : dict</span>
<span class="sd">            Target domains calculated by the last loop.</span>
<span class="sd">        tmpDomains : dict</span>
<span class="sd">            Query domains returned by the current loop.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tol : float</span>
<span class="sd">            Mismatch ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmplist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDomainList</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">minDomains</span><span class="p">))</span>
        <span class="n">reflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">refd</span> <span class="ow">in</span> <span class="n">tmplist</span><span class="p">:</span>
            <span class="n">reflist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">refd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">refd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflist</span><span class="p">):</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmplist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDomainList</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tmpDomains</span><span class="p">))</span>
            <span class="n">alignlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">alignd</span> <span class="ow">in</span> <span class="n">tmplist</span><span class="p">:</span>
                <span class="n">alignlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">alignd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alignd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">Ref</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">reflist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">Align</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="s1">&#39;align&#39;</span><span class="p">,</span> <span class="n">alignlist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">DomainAligner</span><span class="p">(</span><span class="n">Ref</span><span class="p">,</span> <span class="n">Align</span><span class="p">)</span>
            <span class="n">worker</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span><span class="s1">&#39;align&#39;</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">conserved</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span><span class="s1">&#39;align&#39;</span><span class="p">))</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">count</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ref</span><span class="o">.</span><span class="n">Domains</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tol</span></div>

<div class="viewcode-block" id="Chrom.oriIter"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.oriIter">[docs]</a>    <span class="k">def</span> <span class="nf">oriIter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minDomains</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iteratvely approximate adaptive window sizes and return the final</span>
<span class="sd">        bottom domain list which will be used in subsequent procedures. For</span>
<span class="sd">        each loop, window sizes are updated according to the latest bottom</span>
<span class="sd">        domains and next loop will re-run the identification pipeline using</span>
<span class="sd">        new window sizes. The iteration terminates if domains between two</span>
<span class="sd">        consecutive loops are very similar (estimated by</span>
<span class="sd">        :py:meth:`tadlib.hitad.chromLev.Chrom.iterCore`).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minDomains : dict</span>
<span class="sd">            Initial domains served as the target domain list for</span>
<span class="sd">            :py:meth:`tadlib.hitad.chromLev.Chrom.iterCore` at the first</span>
<span class="sd">            iteration. We set it empty in our pipeline.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        minDomains : dict</span>
<span class="sd">            The keys are tuples representing gap-free regions of the chromosome,</span>
<span class="sd">            and the values are corresponding identified bottom domain lists.</span>
<span class="sd">            Start and end of the domain are in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.calDI : calculate DI values according to</span>
<span class="sd">                                            input window sizes</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.minCore : learn HMM parameters and</span>
<span class="sd">                                              identify bottom domains by using</span>
<span class="sd">                                              updated adaptive DIs</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.iterCore : estimate the degree of divergence</span>
<span class="sd">                                               between two domain lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">tmpDomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minCore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regionDIs</span><span class="p">)</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterCore</span><span class="p">(</span><span class="n">minDomains</span><span class="p">,</span> <span class="n">tmpDomains</span><span class="p">)</span>
            <span class="n">minDomains</span> <span class="o">=</span> <span class="n">tmpDomains</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">minDomains</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">minDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]:</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">;</span> <span class="n">de</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                    <span class="n">Len</span> <span class="o">=</span> <span class="n">de</span> <span class="o">-</span> <span class="n">ds</span>
                    <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;0,2,1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Len</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Len</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">[</span><span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">]</span> <span class="o">=</span> <span class="n">ws</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calDI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splitChrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minDomains</span> <span class="o">=</span> <span class="n">minDomains</span></div>

<div class="viewcode-block" id="Chrom.fineDomain"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.fineDomain">[docs]</a>    <span class="k">def</span> <span class="nf">fineDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify hierarchical domains within each TAD.</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        hierDomains : dict</span>
<span class="sd">            The keys are tuples representing gap-free regions of the chromosome,</span>
<span class="sd">            and the values are corresponding identified hierarchical domain lists.</span>
<span class="sd">            Start and end of the domain are in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.maxCore : identify TADs</span>
<span class="sd">        </span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.subDomains : resolve domain hierarchy</span>
<span class="sd">                                                 within a given TAD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hierDomains</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxDomains</span><span class="p">):</span>
            <span class="n">rdomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdomains</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">hdomains</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rdomains</span><span class="p">)):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">rdomains</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">subdomains</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subDomains</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDomains</span><span class="p">[</span><span class="n">region</span><span class="p">],</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refNoise</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                    <span class="n">hdomains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">+</span><span class="p">[</span><span class="n">noise</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">:</span>
                        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refNoise</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                        <span class="n">hdomains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="n">noise</span><span class="p">,</span><span class="n">subdomains</span><span class="p">[</span><span class="n">d</span><span class="p">]])</span>
            <span class="n">hdomains</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hierDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdomains</span></div>
    
<div class="viewcode-block" id="Chrom.callDomain"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.callDomain">[docs]</a>    <span class="k">def</span> <span class="nf">callDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Direct API for our hierarchical domain identification pipeline:</span>
<span class="sd">        </span>
<span class="sd">        - Adaptively estimate window size for each bin.</span>
<span class="sd">          (:py:meth:`tadlib.hitad.chromLev.Chrom.minWindows`)</span>
<span class="sd">        - Calculate adaptive DIs. (:py:meth:`tadlib.hitad.chromLev.Chrom.calDI`)</span>
<span class="sd">        - Perform HMM learning, identify initial bottom domains, and iteratively</span>
<span class="sd">          correct adaptive window size and bottom boundary positions.</span>
<span class="sd">          (:py:meth:`tadlib.hitad.chromLev.Chrom.oriIter`)</span>
<span class="sd">        - Identify TADs based on bottom domains.</span>
<span class="sd">          (:py:meth:`tadlib.hitad.chromLev.Chrom.maxCore`)</span>
<span class="sd">        - Resolve domain hierarchy within each TAD.</span>
<span class="sd">          (:py:meth:`tadlib.hitad.chromLev.Chrom.fineDomain`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minWindows</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calDI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splitChrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oriIter</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxCore</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fineDomain</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="s1">&#39;Completed&#39;</span></div>

<div class="viewcode-block" id="Chrom.idxmatch"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.idxmatch">[docs]</a>    <span class="k">def</span> <span class="nf">idxmatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pair interactions of the given domain with the upstream and downstream</span>
<span class="sd">        interactions under the same genomic distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : [start, end]</span>
<span class="sd">            Domain interval in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cur_store : tuple, (x-coordinates, y-coordinates, interaction frequencies)</span>
<span class="sd">            Interactions within the given domain.</span>
<span class="sd">        up_store : tuple, (x-coordinates, y-coordinates, interaction frequencies)</span>
<span class="sd">            Corresponding upstream interctions.</span>
<span class="sd">        down_store : tuple, (x-coordinates, y-coordinates, interaction frequencies)</span>
<span class="sd">            Corresponding downstream interactions.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">de</span> <span class="o">-</span> <span class="n">ds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">Rawx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;0,2,0&#39;</span><span class="p">,</span> <span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">de</span> <span class="o">-</span> <span class="n">ds</span><span class="p">))</span>
        <span class="n">Rawy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;0,2,1&#39;</span><span class="p">,</span> <span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">],</span> <span class="p">(</span><span class="n">de</span> <span class="o">-</span> <span class="n">ds</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Rawy</span> <span class="o">-</span> <span class="n">Rawx</span>

        <span class="n">Ux</span> <span class="o">=</span> <span class="n">Rawx</span> <span class="o">-</span> <span class="n">d</span>
        <span class="n">Uy</span> <span class="o">=</span> <span class="n">Rawx</span>
        <span class="n">Dx</span> <span class="o">=</span> <span class="n">Rawy</span>
        <span class="n">Dy</span> <span class="o">=</span> <span class="n">Dx</span> <span class="o">+</span> <span class="n">d</span>

        <span class="n">curInters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">Rawx</span><span class="p">,</span> <span class="n">Rawy</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">upInters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">Ux</span><span class="p">,</span> <span class="n">Uy</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">downInters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="n">cur_store</span> <span class="o">=</span> <span class="p">(</span><span class="n">Rawx</span><span class="p">,</span> <span class="n">Rawy</span><span class="p">,</span> <span class="n">curInters</span><span class="p">)</span>
        <span class="n">up_store</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ux</span><span class="p">,</span> <span class="n">Uy</span><span class="p">,</span> <span class="n">upInters</span><span class="p">)</span>
        <span class="n">down_store</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">downInters</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">up_store</span><span class="p">,</span> <span class="n">cur_store</span><span class="p">,</span> <span class="n">down_store</span></div>

<div class="viewcode-block" id="Chrom.stablescore"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.stablescore">[docs]</a>    <span class="k">def</span> <span class="nf">stablescore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate TAD score for the given domain. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : [start, end]</span>
<span class="sd">            Domain interval in base-pair unit.</span>
<span class="sd">            </span>
<span class="sd">        bases : list</span>
<span class="sd">            List of bottom domains within the given domain region.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inout : float</span>
<span class="sd">            TAD score defined as the enrichment between intra-domain interaction</span>
<span class="sd">            frequencies and inter-domain interaction frequencies controlling</span>
<span class="sd">            for the impact of genomic distance.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.idxmatch : Pair intra-domain and inter-domain</span>
<span class="sd">                                               interactions with the same</span>
<span class="sd">                                               genomic distance</span>
<span class="sd">        tadlib.calfea.analyze.Core.longrange : Assign the weight value for each</span>
<span class="sd">                                               intra-domain interaction according</span>
<span class="sd">                                               to the genomic distance and</span>
<span class="sd">                                               the local interaction background.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxmatch</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="c1">## Compare inside-domain interactions with outside ones, larger, better</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[]];</span> <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[]]</span>
        <span class="c1"># Pair with upstream interactions</span>
        <span class="n">Umask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ori</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="p">)</span> <span class="o">&amp;</span>\
                <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Umask</span><span class="p">]]</span>
        <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">outside</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Umask</span><span class="p">]]</span>
        <span class="c1"># Pair with downstream interactions</span>
        <span class="n">Dmask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ori</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="p">)</span> <span class="o">&amp;</span>\
                <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">inside</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Dmask</span><span class="p">]]</span>
        <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">outside</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">Dmask</span><span class="p">]]</span>
        <span class="n">inout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">inside</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">):</span>
                <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSelfMatrix</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">newM</span><span class="p">,</span> <span class="n">convert</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">manipulation</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># 2*ww + 1</span>
                    <span class="n">work</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">Core</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
                    <span class="n">work</span><span class="o">.</span><span class="n">longrange</span><span class="p">(</span><span class="n">pw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ww</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">fE</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">convertMatrix</span><span class="p">(</span><span class="n">work</span><span class="o">.</span><span class="n">fE</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
                        <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                        <span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                        <span class="n">fE</span><span class="p">[</span><span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">,</span><span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">pkv</span> <span class="o">=</span> <span class="n">fE</span><span class="p">[</span><span class="n">fE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">pkv</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">norm</span> <span class="o">=</span> <span class="n">MidpointNormalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pkv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                                 <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pkv</span><span class="p">,</span><span class="mi">99</span><span class="p">),</span>
                                                 <span class="n">midpoint</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">W</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fE</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
                        <span class="n">W</span><span class="p">[</span><span class="n">fE</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">W</span><span class="p">[</span><span class="n">Umask</span><span class="p">],</span> <span class="n">W</span><span class="p">[</span><span class="n">Dmask</span><span class="p">]]</span>
                
            <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">inside</span> <span class="o">-</span> <span class="n">outside</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">inside</span> <span class="o">+</span> <span class="n">outside</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span>
            <span class="n">inout</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">inout</span></div>

    <span class="k">def</span> <span class="nf">_updateCache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stablescore</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>

<div class="viewcode-block" id="Chrom.scoreCache"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.scoreCache">[docs]</a>    <span class="k">def</span> <span class="nf">scoreCache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domainlist</span><span class="p">,</span> <span class="n">cache</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and cache the TAD scores for any combinations of consecutive</span>
<span class="sd">        bottom domains.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domainlist : list of [start,end]</span>
<span class="sd">            List of bottom domain intervals in base-pair unit.</span>
<span class="sd">        cache : dict</span>
<span class="sd">            Cache of the TAD scores. The keys are in (start,end) format,</span>
<span class="sd">            intervals of continuous regions, and the values are corresponding</span>
<span class="sd">            calculated scores.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.stablescore : Calculate TAD score of any</span>
<span class="sd">                                                  genomic interval</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateCache</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">:</span><span class="c1"># Noise domains will stay alone</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxapart</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updateCache</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span></div>

<div class="viewcode-block" id="Chrom.maxscorepath"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.maxscorepath">[docs]</a>    <span class="k">def</span> <span class="nf">maxscorepath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domainlist</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An implementation for our proposed algorithm to find the best separation</span>
<span class="sd">        solution at chromosomal/domain level, given bottom domain list and</span>
<span class="sd">        pre-computed scores.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domainlist : list of [start,end]</span>
<span class="sd">            List of bottom domain intervals in base-pair unit.</span>
<span class="sd">        cache : dict</span>
<span class="sd">            Pre-computed scores for any combinations of continuous bottom</span>
<span class="sd">            domains. The keys are intervals of continuous regions in (start,end)</span>
<span class="sd">            format, and the values are corresponding scores.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bests : set of (sidx, eidx)</span>
<span class="sd">            Each element indicates one merged domain of the solution, represented</span>
<span class="sd">            as (start index, end index) of the input *domainlist*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># score cache uses domain coordinate intervals</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="c1"># Dynamic programming</span>
        <span class="c1"># paths uses domain index intervals</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)):</span>
            <span class="n">Len</span> <span class="o">=</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">-</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">]})</span>
            <span class="n">maxp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pre</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span><span class="n">domainlist</span><span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pre</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Len</span><span class="o">*</span><span class="n">unit</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pre</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxs</span><span class="p">:</span>
                        <span class="n">maxs</span> <span class="o">=</span> <span class="n">pre</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">maxp</span> <span class="o">=</span> <span class="n">pp</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">domainlist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxapart</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">tryget</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tryget</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[(</span><span class="n">domainlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">domainlist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxs</span><span class="o">+</span><span class="n">Len</span><span class="o">*</span><span class="n">unit</span><span class="p">,</span> <span class="n">maxp</span><span class="p">]</span>
        <span class="c1"># Backtacking</span>
        <span class="n">lastp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="n">lasts</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">paths</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lasts</span><span class="p">:</span>
                <span class="n">lasts</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lastp</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">if</span> <span class="n">lastp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">bestpath</span> <span class="o">=</span> <span class="p">[</span><span class="n">lastp</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">domainlist</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lastp</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">lastp</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lastp</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">bestpath</span> <span class="o">=</span> <span class="p">[</span><span class="n">lastp</span><span class="p">]</span> <span class="o">+</span> <span class="n">bestpath</span>

        <span class="n">bests</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bestpath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bests</span></div>

<div class="viewcode-block" id="Chrom.maxCore"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.maxCore">[docs]</a>    <span class="k">def</span> <span class="nf">maxCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform TAD identification. We define TADs as domains to optimize</span>
<span class="sd">        chromosome separation(based on some objective function), which is</span>
<span class="sd">        solved by using an algorithm like dynamic programming implemented in</span>
<span class="sd">        :py:meth:`tadlib.hitad.chromLev.Chrom.maxscorepath`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cache : dict</span>
<span class="sd">            TAD scores for all combinations of consecutive bottom domains</span>
<span class="sd">            will be pre-computed and stored in this dict. The keys are</span>
<span class="sd">            tuples (start, end) representing merged domain intervals.</span>
<span class="sd">            (Default: {})</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        -----------</span>
<span class="sd">        maxDomains : dict</span>
<span class="sd">            Optimized TADs.</span>
<span class="sd">        </span>
<span class="sd">        cache : dict</span>
<span class="sd">            Cached TAD scores.</span>
<span class="sd">            </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.scoreCache : Pre-compute TAD scores for</span>
<span class="sd">                                                 all combinations of consecutive</span>
<span class="sd">                                                 bottom domains.</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.maxscorepath : find the best TAD list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxDomains</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minDomains</span><span class="p">):</span>
            <span class="n">rdomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdomains</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdomains</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">maxDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdomains</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scoreCache</span><span class="p">(</span><span class="n">rdomains</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
            <span class="n">premerge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxscorepath</span><span class="p">(</span><span class="n">rdomains</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
            <span class="n">newdomain</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">premerge</span><span class="p">):</span>
                <span class="n">tl</span> <span class="o">=</span> <span class="n">rdomains</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">newdomain</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">newdomain</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newdomain</span><span class="p">):</span>
                <span class="n">maxDomains</span><span class="p">[</span><span class="n">region</span><span class="p">]</span> <span class="o">=</span> <span class="n">newdomain</span>
                          
        <span class="bp">self</span><span class="o">.</span><span class="n">maxDomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orifilter</span><span class="p">(</span><span class="n">maxDomains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span></div>

<div class="viewcode-block" id="Chrom.subDomains"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.subDomains">[docs]</a>    <span class="k">def</span> <span class="nf">subDomains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">reflist</span><span class="p">,</span> <span class="n">clv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">subdomains</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A recusive method (function) to identify inner domain hierarchy</span>
<span class="sd">        of a TAD (or a domain). Sub-TADs of each level are defined as the</span>
<span class="sd">        best separation of the outer domain.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : [start, end]</span>
<span class="sd">            Outer layer domain interval in base-pair unit.</span>
<span class="sd">        reflist : list</span>
<span class="sd">            List of bottom domains within the region of the outer domain.</span>
<span class="sd">        clv : int</span>
<span class="sd">            Global domain level of the outer domain. The TADs have the level</span>
<span class="sd">            0, the sub-TADs within a TAD have the level 1, and sub-sub-TADs</span>
<span class="sd">            within a sub-TAD have the level 2, and so forth. (Default: 0)</span>
<span class="sd">        aM : 2-D numpy ndarray or None</span>
<span class="sd">            Arrowhead matrix of the outer domain. (Default: None)</span>
<span class="sd">        W : 2-D numpy ndarray or None</span>
<span class="sd">            Weight matrix corresponding to the contact matrix of the outer</span>
<span class="sd">            domain. See :py:meth:`tadlib.hitad.chromLev.Chrom.getWeightMatrix`</span>
<span class="sd">            for detailed calculation. (Default: None)</span>
<span class="sd">        subdomains : dict</span>
<span class="sd">            A container for domains of all hierarchy. The keys are domain</span>
<span class="sd">            intervals in base-pair unit, and values are corresponding</span>
<span class="sd">            global levels.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.maxscorepath : find the best domain list</span>
<span class="sd">                                                   optimally separating</span>
<span class="sd">                                                   domain-level interactions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">localUpdate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
            
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">common</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">yidx</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xidx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">xidx</span> <span class="o">-</span> <span class="n">ori</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">yidx</span><span class="p">)</span>
            <span class="n">mask2</span> <span class="o">=</span> <span class="n">common</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">yidx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xidx</span> <span class="o">&gt;=</span> <span class="n">ori</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">xidx</span> <span class="o">&gt;=</span> <span class="n">yidx</span><span class="p">)</span> <span class="o">&amp;</span>\
                    <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">xidx</span> <span class="o">-</span> <span class="n">ori</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">yidx</span><span class="p">)</span>
            <span class="n">part1</span> <span class="o">=</span> <span class="n">aM</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
            <span class="n">part2</span> <span class="o">=</span> <span class="n">aM</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span>
            <span class="n">merge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">part1</span><span class="p">,</span> <span class="o">-</span><span class="n">part2</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">merge</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">tx</span><span class="p">,</span><span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">W</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">tx</span><span class="o">-</span><span class="n">ty</span><span class="p">,</span><span class="n">tx</span><span class="p">],</span> <span class="n">W</span><span class="p">[</span><span class="n">mask2</span><span class="p">]]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">*</span> <span class="n">weights</span>
                <span class="n">biases</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">biases</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">getsublist</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">reflist</span><span class="p">):</span>
            
            <span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">reflist</span> <span class="k">if</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="ow">and</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
            <span class="n">sublist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">sublist</span>

        <span class="n">subdomains</span><span class="p">[(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">clv</span>
        <span class="k">if</span> <span class="n">aM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toArrowhead</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sublist</span> <span class="o">=</span> <span class="n">getsublist</span><span class="p">((</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reflist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWeightMatrix</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sublist</span><span class="p">)</span>
        <span class="n">xidx</span><span class="p">,</span> <span class="n">yidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">aM</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">common</span> <span class="o">=</span> <span class="p">((</span><span class="n">yidx</span> <span class="o">-</span> <span class="n">xidx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">aM</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">aM</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">biases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sublist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">localUpdate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sublist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">localUpdate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">biases</span><span class="p">[(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">prebests</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxscorepath</span><span class="p">(</span><span class="n">sublist</span><span class="p">,</span> <span class="n">biases</span><span class="p">)</span>
        <span class="c1">#----------------------------------------------------------------------</span>
        <span class="n">prebests</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">prebests</span><span class="p">)</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">sublist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prebests</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="n">prebests</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">dlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sublist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1">#----------------------------------------------------------------------</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nlv</span> <span class="o">=</span> <span class="n">clv</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">tmpdomain</span> <span class="o">=</span> <span class="p">(</span><span class="n">dlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dlist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tmpori</span> <span class="o">=</span> <span class="n">tmpdomain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
            <span class="n">tmpend</span> <span class="o">=</span> <span class="n">tmpdomain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
            <span class="n">taM</span> <span class="o">=</span> <span class="n">aM</span><span class="p">[</span><span class="n">tmpori</span><span class="p">:</span><span class="n">tmpend</span><span class="p">,</span> <span class="n">tmpori</span><span class="p">:</span><span class="n">tmpend</span><span class="p">]</span>
            <span class="n">tW</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">tmpori</span><span class="p">:</span><span class="n">tmpend</span><span class="p">,</span> <span class="n">tmpori</span><span class="p">:</span><span class="n">tmpend</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subDomains</span><span class="p">(</span><span class="n">tmpdomain</span><span class="p">,</span> <span class="n">sublist</span><span class="p">,</span> <span class="n">clv</span><span class="o">=</span><span class="n">nlv</span><span class="p">,</span> <span class="n">aM</span><span class="o">=</span><span class="n">taM</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">tW</span><span class="p">,</span>
                            <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Chrom.getWeightMatrix"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.getWeightMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getWeightMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate weights for each intra-domain interaction by considering</span>
<span class="sd">        the genomic distance and the local interaction background.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int</span>
<span class="sd">            The domain interval in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        bases : list</span>
<span class="sd">            List of the bottom domains within the given interval.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        W : 2-D numpy.ndarray</span>
<span class="sd">            The weight matrix. (An upper triangular matrix)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSelfMatrix</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">newM</span><span class="p">,</span> <span class="n">convert</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">manipulation</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span> <span class="c1"># 2*ww + 1</span>
            <span class="n">work</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">Core</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="n">work</span><span class="o">.</span><span class="n">longrange</span><span class="p">(</span><span class="n">pw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ww</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">fE</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">convertMatrix</span><span class="p">(</span><span class="n">work</span><span class="o">.</span><span class="n">fE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                <span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span>
                <span class="n">fE</span><span class="p">[</span><span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">,</span><span class="n">ds</span><span class="p">:</span><span class="n">de</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pkv</span> <span class="o">=</span> <span class="n">fE</span><span class="p">[</span><span class="n">fE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pkv</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">MidpointNormalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pkv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                                         <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pkv</span><span class="p">,</span><span class="mi">99</span><span class="p">),</span>
                                         <span class="n">midpoint</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fE</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
                <span class="n">W</span><span class="p">[</span><span class="n">fE</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
                
        <span class="k">return</span> <span class="n">W</span></div>
        

<div class="viewcode-block" id="Chrom.getSelfMatrix"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.getSelfMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getSelfMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the contact matrix of any given region.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int</span>
<span class="sd">            The region interval in base-pair unit.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Matrix : 2-D numpy ndarray, float</span>
<span class="sd">            Sub contact matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startidx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="n">endidx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>

        <span class="n">Matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">startidx</span><span class="p">:</span><span class="n">endidx</span><span class="p">,</span> <span class="n">startidx</span><span class="p">:</span><span class="n">endidx</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">Matrix</span><span class="p">)</span>
        <span class="n">Matrix</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Matrix</span></div>

<div class="viewcode-block" id="Chrom.refNoise"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.refNoise">[docs]</a>    <span class="k">def</span> <span class="nf">refNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return noise level of a domain, which is simply defined as the zero</span>
<span class="sd">        entry ratio of the contact matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">minsize</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSelfMatrix</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">total</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_rm</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span>\
                <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="n">nx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm</span>
            <span class="n">sigNum</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Number of nonzero entries apart from diag</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">sigNum</span><span class="o">/</span><span class="n">total</span></div>

<div class="viewcode-block" id="Chrom.toArrowhead"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.toArrowhead">[docs]</a>    <span class="k">def</span> <span class="nf">toArrowhead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Arrowhead transformation on contact matrix of a given</span>
<span class="sd">        genomic region.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int</span>
<span class="sd">            The region interval.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A : 2-D numpy ndarray, float</span>
<span class="sd">            Transformed matrix. (A symmetric matrix)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startidx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>
        <span class="n">endidx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromLen</span>

        <span class="n">maxd</span> <span class="o">=</span> <span class="n">endidx</span> <span class="o">-</span> <span class="n">startidx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">forward</span> <span class="o">=</span> <span class="n">startidx</span> <span class="o">-</span> <span class="n">maxd</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawMatrix</span><span class="p">[</span><span class="n">forward</span><span class="p">:</span><span class="n">endidx</span><span class="p">,</span> <span class="n">forward</span><span class="p">:</span><span class="n">endidx</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="n">raw</span><span class="p">[</span><span class="n">ty</span><span class="p">,</span> <span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">]</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">maxd</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">rawx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">maxd</span>
        <span class="n">rawy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">maxd</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span>
        <span class="n">minusY</span> <span class="o">=</span> <span class="n">rawx</span> <span class="o">-</span> <span class="n">d</span>

        <span class="n">denominator</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">minusY</span><span class="p">,</span> <span class="n">rawx</span><span class="p">]</span> <span class="o">+</span> <span class="n">raw</span><span class="p">[</span><span class="n">rawx</span><span class="p">,</span> <span class="n">rawy</span><span class="p">]</span>
        <span class="n">denominator</span><span class="p">[</span><span class="n">denominator</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">elemA</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">minusY</span><span class="p">,</span> <span class="n">rawx</span><span class="p">]</span> <span class="o">-</span> <span class="n">raw</span><span class="p">[</span><span class="n">rawx</span><span class="p">,</span> <span class="n">rawy</span><span class="p">])</span> <span class="o">/</span> <span class="n">denominator</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">A</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemA</span>
        <span class="n">A</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemA</span>

        <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="Chrom.plot"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.Chrom.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">Domains</span><span class="p">,</span> <span class="n">figname</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">arrowhead</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a genomic region and a domain list, plot corresponding contact</span>
<span class="sd">        heatmap and all domains (represented as diagonal squares) within the</span>
<span class="sd">        region.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int</span>
<span class="sd">            The region interval.</span>
<span class="sd">        Domains : dict</span>
<span class="sd">            The keys are tuples representing gap-free regions, and values</span>
<span class="sd">            are corresponding identified domains.</span>
<span class="sd">        figname : str or None</span>
<span class="sd">            If not None, the figure will be saved, otherwise it will only be</span>
<span class="sd">            shown in an interactive window. (Default: None)</span>
<span class="sd">        arrowhead : bool</span>
<span class="sd">            If True, the Arrowhead transformed matrix will be plotted instead</span>
<span class="sd">            of the raw contact matrix. (Default: False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">LinearSegmentedColormap</span>

        <span class="k">def</span> <span class="nf">caxis_H</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Axis control for the heatmap.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">caxis_S</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Axis control for the DI track.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">right</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">labeltop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">labelleft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">labelright</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;#1B9E77&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_linestyle</span><span class="p">(</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">properU</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Express a genomic position in proper unit (KB or MB).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">i_part</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">//</span> <span class="mi">1000000</span> <span class="c1"># Integer Part</span>
            <span class="n">d_part</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">//</span> <span class="mi">1000</span> <span class="c1"># Decimal Part</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">i_part</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_part</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i_part</span><span class="p">),</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">d_part</span><span class="p">),</span> <span class="s1">&#39;K&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">i_part</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">d_part</span><span class="p">),</span> <span class="s1">&#39;K&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i_part</span><span class="p">),</span> <span class="s1">&#39;M&#39;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">boundDrawer</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#A5ACAF&#39;</span><span class="p">):</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">bi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">bi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">startidx</span><span class="p">)</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span>
                            <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span>
                            <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">)</span>

        <span class="c1"># Basic Settings</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;xtick.direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;out&#39;</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;ytick.direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;out&#39;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="mf">0.618</span><span class="p">;</span> <span class="n">Left</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">HB</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">HH</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># HeatMap Bottom / HeatMap Height</span>
        <span class="n">SB</span> <span class="o">=</span> <span class="n">HB</span> <span class="o">+</span> <span class="n">HH</span> <span class="c1"># Bottom of tracks</span>
        <span class="n">ST</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="c1"># The Top of tracks</span>
        <span class="n">SH</span> <span class="o">=</span> <span class="p">(</span><span class="n">ST</span> <span class="o">-</span> <span class="n">SB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">raw_cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s1">&#39;interaction&#39;</span><span class="p">,</span>
                                                     <span class="p">[</span><span class="s1">&#39;#FFFFFF&#39;</span><span class="p">,</span><span class="s1">&#39;#CD0000&#39;</span><span class="p">])</span>
        <span class="n">arrow_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">RdBu_r</span>
        <span class="n">DI_color</span> <span class="o">=</span> <span class="s1">&#39;#1B9E77&#39;</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arrowhead</span><span class="p">:</span>
            <span class="n">Matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toArrowhead</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">MidpointNormalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">Matrix</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">midpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">vmax</span><span class="o">=</span><span class="n">Matrix</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">Params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span> <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">arrow_cmap</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSelfMatrix</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">Matrix</span><span class="p">)]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">nonzero</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
            <span class="n">Params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vmax&#39;</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">raw_cmap</span><span class="p">}</span>

        <span class="n">startidx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
        <span class="n">endidx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="n">Left</span><span class="p">,</span> <span class="n">HB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">HH</span><span class="p">])</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
                       <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">interval</span><span class="p">),</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">Params</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ticks</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">properU</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>

        <span class="n">Domains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getDomainList</span><span class="p">(</span><span class="n">Domains</span><span class="p">)]</span>
        <span class="n">Domains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;1,2,0&#39;</span><span class="p">,</span> <span class="n">Domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">Domains</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">Domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
        <span class="n">Domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
        <span class="c1"># Top-level</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">startidx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">endidx</span><span class="p">)</span>
        <span class="n">extract</span> <span class="o">=</span> <span class="n">Domains</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">boundDrawer</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">extract</span><span class="p">,</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#60636A&#39;</span><span class="p">)</span>
        <span class="c1"># Lower-level</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">startidx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">endidx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Domains</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">extract</span> <span class="o">=</span> <span class="n">Domains</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">boundDrawer</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">extract</span><span class="p">,</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#A5ACAF&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">caxis_H</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">axc</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="n">Left</span> <span class="o">+</span> <span class="n">width</span> <span class="o">+</span> <span class="mf">0.08</span><span class="p">,</span> <span class="n">HB</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">HH</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cax</span> <span class="o">=</span> <span class="n">axc</span><span class="p">)</span>

        <span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIs</span><span class="p">[</span><span class="n">startidx</span><span class="p">:</span><span class="n">endidx</span><span class="p">]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="n">Left</span><span class="p">,</span> <span class="n">SB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">SH</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">track</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">track</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">DI_color</span><span class="p">,</span>
                        <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Adaptive DI&#39;</span><span class="p">,</span> <span class="n">labelpad</span> <span class="o">=</span> <span class="mi">43</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                      <span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;italic&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">caxis_S</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">DI_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">figname</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="MultiReps"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.MultiReps">[docs]</a><span class="k">class</span> <span class="nc">MultiReps</span><span class="p">(</span><span class="n">DomainAligner</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We define *MultiReps* to:</span>
<span class="sd">    </span>
<span class="sd">    - Hold Hi-C data of the same chromosome from different biological replicates</span>
<span class="sd">      at the same time</span>
<span class="sd">    - Provide an interface to identify hierarchical domains by using different</span>
<span class="sd">      replicate data independently and maintain the reproducible domains to</span>
<span class="sd">      form the final domain list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chrom : str</span>
<span class="sd">        Chromosome label.</span>
<span class="sd">    res : int</span>
<span class="sd">        Hi-C data resolution in base-pair unit.</span>
<span class="sd">    datasets : dict</span>
<span class="sd">        The keys are unique replicate labels, and the values are constructed</span>
<span class="sd">        *Chrom* objects by using the Hi-C data of corresponding biological</span>
<span class="sd">        replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">datasets</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Queue</span> <span class="o">=</span> <span class="n">datasets</span> <span class="c1"># key: rep label, value: Chrom object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="s1">&#39;Unfinished&#39;</span>

<div class="viewcode-block" id="MultiReps.getDomainList"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.MultiReps.getDomainList">[docs]</a>    <span class="k">def</span> <span class="nf">getDomainList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byregion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine by-region domains into a single list.</span>
<span class="sd">        </span>
<span class="sd">        Each domain in the returned list is represented in the format</span>
<span class="sd">        ``[chromosome label, start bp, end bp, hierarchical level]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domainlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">byregion</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">byregion</span><span class="p">[</span><span class="n">region</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                    <span class="n">domainlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">domainlist</span></div>

<div class="viewcode-block" id="MultiReps.callDomain"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.MultiReps.callDomain">[docs]</a>    <span class="k">def</span> <span class="nf">callDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find reproducible domains between replicates by using our</span>
<span class="sd">        domain-level alignment strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Queue</span><span class="p">)</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDomainList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="n">reps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">hierDomains</span><span class="p">)</span>
        <span class="n">tg</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">reps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">ql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDomainList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span><span class="o">.</span><span class="n">hierDomains</span><span class="p">)</span>
            <span class="n">qy</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">rep</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reproducible</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">))</span>
            <span class="n">tg</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="s1">&#39;mtg&#39;</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
        
        <span class="n">pool</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correctDomainTree</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">Domains</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">mergedDomains</span> <span class="o">=</span> <span class="n">hierFormat</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="s1">&#39;Completed&#39;</span></div>
    
    <span class="k">def</span> <span class="nf">_correctDomainTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">cur</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">ref_e</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">subtree</span><span class="p">:</span>
            <span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ref_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ref_e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cur</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">-</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">ref_s</span>
                <span class="k">if</span> <span class="n">cur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">ref_e</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">chrom</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_correctDomainTree</span><span class="p">(</span><span class="n">subtree</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">pool</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<div class="viewcode-block" id="MultiReps.reproducible"><a class="viewcode-back" href="../../../hitad_api.html#tadlib.hitad.chromLev.MultiReps.reproducible">[docs]</a>    <span class="k">def</span> <span class="nf">reproducible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subprocess of *callDomain* for replicate alignment and reproducibility</span>
<span class="sd">        determination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">repAligner</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
        <span class="n">tcache</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
        <span class="n">qcache</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">qy</span><span class="p">,</span> <span class="n">tg</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_customize</span><span class="p">(</span><span class="n">tcache</span><span class="p">,</span> <span class="n">qcache</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="n">qbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_customize</span><span class="p">(</span><span class="n">qcache</span><span class="p">,</span> <span class="n">tcache</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">tg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">qbase</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="n">hierFormat</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dlist</span></div>
    
    <span class="k">def</span> <span class="nf">_iscompatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dlist</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        
        <span class="n">dlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">lvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlist</span><span class="p">:</span>
            <span class="n">lvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">boundclass</span><span class="p">[(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">lvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">boundclass</span><span class="p">[(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lvs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inlv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lvs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">blv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lvs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lvs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">inlv</span> <span class="o">&gt;=</span> <span class="n">blv</span>
    
    <span class="k">def</span> <span class="nf">_correct_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">backward</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">me</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">[</span><span class="n">lv</span><span class="p">]:</span>
                <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">info</span>
                <span class="n">tcheck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iscompatible</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">tg</span><span class="p">)</span>
                <span class="n">qcheck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iscompatible</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tcheck</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">qcheck</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                        <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">continue</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">backward</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                        <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mlv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">mlv</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">continue</span>
                    <span class="n">ck</span> <span class="o">=</span> <span class="p">[</span><span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ql</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">blv</span> <span class="ow">in</span> <span class="n">backward</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">backward</span><span class="p">[</span><span class="n">blv</span><span class="p">]:</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                            <span class="k">if</span> <span class="p">((</span><span class="n">ck</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">ck</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">ck</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">or</span> \
                               <span class="p">((</span><span class="n">ck</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">ck</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">ck</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                                <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">valid</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span> <span class="o">=</span> <span class="n">ql</span><span class="p">,</span> <span class="n">tl</span>
                            <span class="n">mlv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">]))</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">mlv</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
                                <span class="n">pool</span><span class="p">[</span><span class="n">mlv</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">1</span><span class="p">])}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">pool</span><span class="p">[</span><span class="n">mlv</span><span class="p">][</span><span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">me</span><span class="p">:</span>
                            <span class="n">pool</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                            
    
    <span class="k">def</span> <span class="nf">_correct_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">backward</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">):</span>
        
        <span class="n">pool</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correct_core</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">backward</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_correct_core</span><span class="p">(</span><span class="n">backward</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">pool</span>
    
    <span class="k">def</span> <span class="nf">_customize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        
        <span class="n">tcore</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cache</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sk</span> <span class="o">=</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="n">sk</span><span class="p">]</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">info</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># wait for reverse alignment</span>
                <span class="k">continue</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_pairs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">hit</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
            <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">target</span><span class="p">[</span><span class="n">lv</span><span class="p">]:</span>
                    <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">info</span>
                    <span class="n">tlvs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)):</span>
                        <span class="n">mlv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tlvs</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">mlv</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">:</span>
                                <span class="n">nk</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="kc">None</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                                    <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">nk</span><span class="p">:</span><span class="n">Container</span><span class="p">([[</span><span class="n">d</span><span class="p">],[]])}</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([[</span><span class="n">d</span><span class="p">],[]])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">mlv</span> <span class="ow">in</span> <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                                <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">mlv</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span><span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">])}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">mlv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span><span class="n">ql</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">:</span>
                            <span class="n">nk</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="kc">None</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                                <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">nk</span><span class="p">:</span><span class="n">Container</span><span class="p">([[</span><span class="n">d</span><span class="p">],[]])}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">tcore</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">([[</span><span class="n">d</span><span class="p">],[]])</span>
        
        <span class="n">source</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tcore</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">tcore</span>

    <span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">tg</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
            <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">info</span>
            <span class="n">topobounds</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># bounds of higher levels should be passed down</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">topobounds</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">Domains</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topobounds</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">tl</span><span class="p">):</span>
                    <span class="n">topobounds</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">Domains</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topobounds</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">lv</span><span class="p">]:</span>
                    <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">lv</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">info</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTopo</span><span class="p">(</span><span class="n">topobounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ql</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topobounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">new</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topobounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">new</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_updateTopo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topo</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">topo</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updateTopo</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">d</span>
    
    <span class="k">def</span> <span class="nf">_getTopo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topo</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        
        <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">topo</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTopo</span><span class="p">(</span><span class="n">topo</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="k">return</span> <span class="n">bounds</span>
    
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">d1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">d2</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rawlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill holes for domains of all levels. We skip gap regions detected</span>
<span class="sd">        on any biological replicate dataset.</span>
<span class="sd">        </span>
<span class="sd">        Consider [[&#39;1&#39;,0,200000],[&#39;1&#39;,350000,600000]], then the region</span>
<span class="sd">        [200000,350000] is defined as a hole in original domain list.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rawlist : list</span>
<span class="sd">            Original domain list. Each domain is represented by</span>
<span class="sd">            [chrom,start,end,label], in which *start* and *end* should be</span>
<span class="sd">            in base-pair unit, and *label* indicates the hierarchical level</span>
<span class="sd">            of the domain.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        domainlist : list</span>
<span class="sd">            Domain list after hole filling.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tadlib.hitad.chromLev.Chrom.splitChrom : where the gap regions are</span>
<span class="sd">                                                 detected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gapbins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Queue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gapbins</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span><span class="o">.</span><span class="n">gapbins</span><span class="p">)</span>
        
        <span class="n">bo</span> <span class="o">=</span> <span class="n">BoundSet</span><span class="p">(</span><span class="s1">&#39;pse&#39;</span><span class="p">,</span> <span class="n">rawlist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">rawlist</span><span class="p">:</span>
            <span class="n">D</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># Hash the domain list</span>
            <span class="n">newlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">td</span> <span class="o">=</span> <span class="p">(</span><span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bo</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">td</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">td</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dbset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">td</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">td</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">))</span>
            <span class="n">gapratio</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dbset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gapbins</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dbset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gapratio</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">td</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="n">newlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">td</span><span class="p">))</span>

        <span class="n">domainlist</span> <span class="o">=</span> <span class="n">hierFormat</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">domainlist</span></div>

<span class="k">class</span> <span class="nc">repAligner</span><span class="p">(</span><span class="n">DomainAligner</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A customized *tadlib.hitad.aligner.DomainAligner* for hierarchical</span>
<span class="sd">    domain alignment between two replicates.</span>
<span class="sd">    </span>
<span class="sd">    The API stays the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">DomainAligner</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">):</span>
        
        <span class="c1"># First, align the top-level domains</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">Domains</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tql</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">qy</span><span class="o">.</span><span class="n">Domains</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ttg</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">tg</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">tqy</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">qy</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">tql</span><span class="p">,</span> <span class="n">qy</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligncore</span><span class="p">(</span><span class="n">ttg</span><span class="p">,</span> <span class="n">tqy</span><span class="p">)</span>
        
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ftg</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tg</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">ql</span> <span class="o">=</span> <span class="n">qy</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">fqy</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">qy</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qy</span><span class="o">.</span><span class="n">res</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c1"># Parse the hierarchy step by step</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ftg</span><span class="o">.</span><span class="n">levs</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">tv</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">tl</span> <span class="o">=</span> <span class="n">ftg</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">tv</span><span class="p">,)))</span>
                <span class="n">ntg</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">ftg</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">ftg</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">ql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_localhits</span><span class="p">(</span><span class="n">ntg</span><span class="p">,</span> <span class="n">fqy</span><span class="p">)</span>
                <span class="n">nqy</span> <span class="o">=</span> <span class="n">DomainSet</span><span class="p">(</span><span class="n">fqy</span><span class="o">.</span><span class="n">Label</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">fqy</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">npairs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligncore</span><span class="p">(</span><span class="n">ntg</span><span class="p">,</span> <span class="n">nqy</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">npairs</span><span class="p">:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">tv</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">Container</span><span class="p">(</span><span class="n">npairs</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">cache</span>
    
    <span class="k">def</span> <span class="nf">_toberobust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">t_ref</span><span class="p">,</span> <span class="n">q_ref</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">t_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">ql</span> <span class="o">=</span> <span class="n">qy</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">t_ref</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ql</span> <span class="o">=</span> <span class="n">q_ref</span><span class="o">.</span><span class="n">getregion</span><span class="p">(</span><span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="n">tl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">ql</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">bylev</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="n">olev</span> <span class="o">=</span> <span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ql</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">olev</span><span class="p">:</span>
                <span class="n">bylev</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">olev</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">bylev</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bylev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># query domain levels are heterogeneous</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">([</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ql</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bylev</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">([</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">ref</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">ref</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">ql</span> <span class="o">=</span> <span class="n">hit</span>
                
        <span class="n">tk</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">tl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="p">(</span><span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ql</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">tk</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="p">[</span><span class="n">tl</span><span class="p">,</span> <span class="n">ql</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017, XiaoTao Wang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/XiaoTaoWang/TADLib" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>